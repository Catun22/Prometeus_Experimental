# alpha v.0.3.0 экспериментального проекта Prometheus

Вход в программу находится в `__main__.py`. 

> По желанию вы можете установить нужные библиотеки с помощью: **`pip install -r requirements.txt`**.
> 
> В `requirements.txt` вошли две библиотеки: `rich` и `colorama`.
> 
> При этом использоване `rich` необходимо для программы, а `colorama` не обязательна.

> Вы можете установить `rich` и `colorama` по отдельности:
> 
> `pip install rich`
> 
> `pip install colorama`

### Изменения в проекте:

- Изменен файл `actions.py`

В файл `actions.py` вошлел новый метод: `__redactor_helper_linux`. Этот метод позволяет корректно открывать приложения и файлы в дистрибутивах Linux.

Также изменены методы: `__support_open_app`, `create_item`, `look_item`.

Теперь, благодаря соответствующим добавлениям и изменениям стало возможным открывать файлы в соответствующих редакторах.

В список редакторов вошли, наприме: `nano`, `vim`, `code`...

Данные изменения никак не влияют на работу программы в Windows или MacOs.

## **Добавьте свои пути в файле `config.json`!**

По умолчанию все создаваемые программой файлы будут создаваться в папке `Storage`, рядом с точкой входа в проект, то есть `Prometeus`, рядом с `__main__.py`. То есть это универсальный путь.

Обратите внимание, что в файле `config.json` пути "разбиты" на две составляющие по смыслу: для классов и для бэкапов.

## Как создать свои методы?

1. Создайте метод в классе `CLI`, в файле `actions.py` (вы можете добавлять любые методы в этот класс). Пример:
   
```python
# Метод 1
def create_topic(self):
        """Создает шаблон для тем по программированию (python)
        """
        self.create_item(cls=Topic, title_prompt=Prompts.theme, path_key="topic")
```
 
1. Укажите имя функции следующим образом в `actions.json`:

```json
"create_topic": "create_topic",
```
3. Пропишите в `menu.json` структуру вызова вашего метода следующим образом:

```json
"Работать": {
    "Учиться": {
        "Учить программирование": {
            "Python": {
                "Тема": {
                    "Создать тему": "create_topic",
                    "Посмотреть список тем": "look_topic"
                }
            }
        }
    }
}
```

Не обязательно создавать гигантские подменю, чтобы вызвать фунцию. Вы можете сократить свое меню, напрмер так:

```json
"Python": {
    "Тема": {
        "Создать тему": "create_topic",
        "Посмотреть список тем": "look_topic"
    }
}
```


## Папка `core`:

Папка `core` содержит `menu.py` несколько других папок:

- lib

- utilits

### Несколько слов о: `menu.py`

Этот модуль, пожалуй, основа всей программы. Именно благодаря этому модулю существует возможность интерактивно перемещаться по меню, выбирать множество функций, которые интерпретатор должен совершить.

Механизм этого модуля на первый взгляд может показаться сложным. Тем более, что он использует концепцию ООП, а не просто функции, как это "было привычно делать для меню".


## Папка `lib`

Эта папка содержит в себе:

- **system_apps**

- `actions.py`

- `patterns.py`

- `prompts.py`

- `dictionary.py`

### Несколько слов о: `actions.py`

В этом модуле есть класс `CLI`, содержащий в себе множество методов, в которых созданы объекты из `patterns.py`.

Словарь `ACTIONS` удален из `actions.py` и заменен на `actions.json`ю

Json файл всё также содержит в себе ключи и **значения** (идентичные ключам, для простоты), которые в свою очередь **являются ссылками к функциям**, описанным в модуле выше.

### Несколько слов о: `patterns.py`

Это всего-лишь один из возможных модулей, которые можно подключить сюда. Суть этого модуля в том, что он содержит в себе классы, позволяющие создавать файлы с расширением `.md` с уже готовыми шаблонами для конспектов.

Что я имею ввиду: Теоретически, вы можете подключить сюда сколько угодно различных модулей, создать сколько угодно различных функций в `actions.py` и управлять своим персональным компьютером как угодно.

Я специально оставил некоторые заготовки здесь, для наглядности (к слову, можете ими пользоваться как вам вздумается).

Во время создания этого механизма я рассчитывал на его расширяемость и гибкость.

Сейчас в нем содержится неимоверное множество различных классов. Вы можете наследоваться от самого первого класса `TemplateMd` или создать свои классы.

> Между прочим, `.md` <mark>поддерживает</mark> `html` синтаксис. А также используется в различных программах, например в известной **Obsidian**.

Также вы можете дать **Obsidian** создаваему этой программой папку `Storage` и использовать уже готовые конпоненты для заметок.

**> К слову, в классы была добавлена возможность создавать теги, которые поддерживает Obsidian.**

### Несколько слов о: `prompts.py`

Этот модуль содержит в себе несколько классов, например: `class Prompts` и `class MenuPrompts`. Эти классы всего-лишь контейнеры, служащие для хранения в них "раскрашенных строк".

Почему я вынес строки в отдельных файл, а не раскрасил их в каком-нибудь `actions.py`? Вся причина кроется в расширяемости, гибкости и скорости изменения.

При такой архитектуре, вы легко можете изменить под себя цвет вывода в терминале. 

Моей задумкой была возможность "изменения тем". То есть, можно сделать класс, который менял бы тему в этом файле на какую-то определенную, кастомную.

#### На данный момент `prompts.py` имеет потенциал для изменения своей "темы".

Чтобы изменить темы в `prompts.py`, просто измените цвета вот здесь:

```python
class Default:
    default_theme_green = "#00B74A" + " bold"
    default_theme_yellow = "#FFCF00" + " bold"
    default_theme_red = "#FF3100" + " bold"
    default_theme_blue = "#3415B0" + " bold"
    white = "#FFFFFF" + " bold"

main_color = Default.default_theme_green
second_color = Default.default_theme_yellow
third_color = Default.default_theme_red
additional_color = Default.default_theme_blue
support_color = Default.white  # Цвет для  цифр и прочего текста
```

### Несколько слов о: `dictionary.py`

Этот файл содержит в себе два класса: `Word` и `Dictionary`, а также функцию `interactive_mode()`.

`Word` - отвечает за слова, `Dictionary` - отвечает за словарь, а `interactive_mode()` за интерактивную работу с словарем.

Вы можете задвать значения напрямую или пользоваться интерактивным режимом.

`Dictionary` создаст файл `.md` формата, в котором и будет хранить словарь в виде текста.

Конечно, было бы куда лучше использовать `SQLite`. Однако на данный момент у автора не достаточно навыков для работы с `БД`.

По большому счёту это самостоятельный модуль и вы можете использовать его и вне этого проекта.

#### **! На данный момент "поддерживаются" 5 языков (русский ,английский, немецкий, французский, испанский), однако вы легко можете расширить количество поддерживаемых языков!**

У словаря нет ограничений по количеству слов или языков - вы можете создать любое количество слов и языков. Просто не забудьте написать какие языки вы используете чаще всего:

```python
# Тут:
    enter_language = (
        Text(
            "Введите язык перевода:\n"
            "\n"
            "English [en] - английский\n"
            "Deutsch [ge] - немецкий\n"
            "Français [fr] - французский\n"
            "Español [es] - испанский\n"
            "\n"
            "Для завершения введите: стоп",
            style=main_color,
        )
        + Text("Для завершения введите: '")
        + __stop
        + Text("'")
    )

# И тут
    new_language = Text(
        "Введите язык:\n"
        "English [en] - английский\n"
        "Deutsch [ge] - немецкий\n"
        "Français [fr] - французский\n"
        "Español [es] - испанский",
        style=main_color,
    )
```

Этот код находится в `prompts.py`.

Механизм, который позволяет сохранить любое количество языков - ***цикл***.

## Папка `system_apps`

Эта папка содержит:

- `back.py`- создает бэкап при вызове. Предназначен для создания бэкапов словаря, создаваемого `dictionary.py`. Он создаст новую папку Backup и скопирует туда словарь `.md`. 
Вы можете задать необходимое количество бэкапов при вызове этого модуля.

- `findler.py` - небольшая утилита по поиску файлов по имени.

## Папка `utilits`

Эта папка содержит в себе три файла:

- `cleaner.py`
- `installer.py`
- `opener_json.py`

### Несколько слов о: `cleaner.py`

Функция этого модуля: просто очистить терминал от текста (в зависимости от операционной системы (ОС)). В скрипте используется два раза, из-за `installer.py`.

### Несколько слов о: `installer.py`

Функция этого модуля: установить библиотеку colorama для ОС Windows и вызвать функцию `just_fix_windows_console()`.

Предусмотрен отказ от установки (однако он будет появляться при каждом запуске программы). Если вы действительно не хотите устанавливать colorama, то просто уберите вызов `installer.py` и один вызов `cleaner.py` в `__main.py__`.

### Несколько слов о: `opener_json.py`

Функция этого файла позволяет распаковать данные в json файле.

### Стандартная библиотека:

- **`typing`** - для аннотаций.
- **`os`** - для работы с путями.
- **`sys`** - чтобы узнать используемую ОС и отправить команду на оболочку.
- **`ctypes`**
- **`date`** - создать дату создания в `patterns.py`.
- **`subprocess`** - для запуска веб-сайтов и приложений на устройстве.

### Не стандартная библиотека:

- **`rich`** - обязательно к установке.
- **`colorama`** - по необходимости.

## Цель

> Основная цель этого проекта- применить принципы ООП, для создания универсальной, гибкой, расширяемой программы по управлению процессами в компьютере.

Принципы: 
> **"Всё что в модуле - остаётся в модуле"** & **"Не повторяй сам себя"**.

Пример структуры кода вы можете посмотреть в файле `__main__.py`, примеры шаблонов в файлах `patterns.py`, примеры методов в  `actions.py`.


## Функционал программы:

При запуске `__main__.py`, вызываются функции `cleaner.py` и `installer.py`, которые выполняют первоначальную обработку терминала и первые "встречаются с пользователм". Пользователь видит приветствие после отработки этих функций.

Далее создается объект класса `Menu` и "запускается". Основной процесс переходит в "руки" `menu.py`.

Внутри `menu.py` отрисовывается само меню, импортированное из `json`.

На этом этапе вы уже можете "ходить" по меню туда-обратно, натыкаясь на "заглушки".

Каким образом меню понимает где заглушка, а где дейстаие (ссылка на функцию)?

Это происходит следующим образом: в `actions.json` мы не зря делали словарь. Именно этот словарь нужно раскрыть и передать как аргумент в класс `Menu`. Внутри меню поймет, что это функции и попытается "вызвать" их.

Вот здесь:
```python
action = self.__actions.get(sub)
if action:  # Выполняем действие
    action()
else:  # Если там ни словарь, ни функция, а заглушка
    print(f"{MenuPrompts.perform_action} {selected}")
```

Соответственно, вызывается определенный метод из `actions.py`, в который мы любезно не забыли положить объеты из `patterns.py`.

Образно говоря, в `actions.py`, в классе `CLI` мы можем хранить десятки и сотни методов. И не обязательно, чтобы эти объекты были из `patterns.py`. И вовсе не обязательно хранить их в `CLI` вовсе.

В проекте продемонстировано создание шаблонов `.md` для изучения программирования, языков и прочих наук.

Для чего было создано так много классов в `patterns.py` и методов в `CLI`? Для демонстрации возможностей этой программы. Не так уж и сложно очистить все не нужные для вас методы и написать в них свои, новые.

Впрочем всё остальное зависит от вас, дорогой читатель.


> ### *"Cogito ergo sum"*

### Пример выполнения программы

```python
##################################
# Пример начального меню:

╭─ Cogito ────────────────────╮
│ Добро пожаловать, господин! │
╰────────────────── ergo sum ─╯
──────────── МЕНЮ ──────────── 
1. Открыть
2. Работать
3. Отдыхать
4. Система
5. Настройки
6. Назад
7. Выход
Чем вы займетесь сегодня?
>>> 
##################################
# Интерактивный словарь:

╭─ English-Français ────╮
│ ИНТЕРАКТИВНЫЙ СЛОВАРЬ │
╰───── Deutsch-Español ─╯
1. Добавить слово
2. Найти слово
3. Редактировать слово
4. Удалить слово
5. Показать список слов
6. Сохранить словарь
7. Выйти

 Выберите действие (1-7)
>>> 
##################################
# Схема проекта:
\Prometheus
┣━━ README.md
┣━━ __main__.py
┣━━ actions.json
┣━━ config.json
┣━━ menu.json
┣━━ core
┃   ┣━━ lib
┃   ┃   ┣━━ actions.py
┃   ┃   ┣━━ dictionary.py
┃   ┃   ┣━━ patterns.py
┃   ┃   ┣━━ prompts.py
┃   ┃   ┗━━ system_apps
┃   ┃       ┣━━ back.py
┃   ┃       ┗━━ findler.py
┃   ┣━━ menu.py
┃   ┗━━ utilits
┃       ┣━━ cleaner.py
┃       ┣━━ installer.py
┃       ┗━━ opener_json.py
┗━━ requirements.txt
```



P.S

(На самом деле автор не договаривает на счёт цели создания этой программы. Истинная цель автора: борьба с поверхностными знаниями (или вовсе с полным невежеством), по крайней мере в базовых сферах жизни - языки, финансы, право и прочее; ускорение самого процесса обучения в общем,и ускорение написания конспектов в частности).